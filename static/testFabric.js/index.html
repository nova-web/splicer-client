<!DOCTYPE >
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!-- <link rel="stylesheet" type="text/css" href="./css/index.css" /> -->
    <script src="./fabric.js"></script>
    <script src="./guidelines.js"></script>
    <script src="./jquery-1.7.1.min.js"></script>
    <title>test Fabric.js</title>
  </head>
  <style>
    .content {
      width: 100%;
      height: 100%;
      position: relative;
    }
    canvas {
      border: 1px solid green;
      position: absolute;
      left: 0;
      top: 0;
    }
    .button {
      margin: 15px;
    }
  </style>
  <body>
    <div class="content"><button id="select-btn" class="button" type="button">查看当前选中canvas信息</button><button id="inline-btn" class="button" type="button">清除当前选中canvas</button><canvas id="canvas" width="800" height="800"></canvas></div>
    <!---->
    <script>
      $(document).ready(function() {
        let canvas = new fabric.Canvas('canvas');
        // 辅助线
        initAligningGuidelines(canvas);
        fabric.Object.prototype.transparentCorners = false; // 不透明
        fabric.Object.prototype.lockRotation = true;
        fabric.Object.prototype.hasRotatingPoint = false;
        fabric.Object.prototype.selectable = true;
        fabric.Object.prototype.padding = 0;
        // 禁用组选择
        canvas.selection = false;

        // ------------------------------------------------------------

        // ------------------------------------------------------------
        // canvas表格--物理 实线
        let gridsize = 400; // 表格个数宽度
        let cellWidth = 400; // 表格大小
        for (var x = 1; x < canvas.width / gridsize; x++) {
          canvas.add(new fabric.Line([cellWidth * x, 0, cellWidth * x, 800], { stroke: '#000000', strokeWidth: 1, selectable: false })); // 竖线
          canvas.add(new fabric.Line([0, cellWidth * x, 800, cellWidth * x], { stroke: '#000000', strokeWidth: 1, selectable: false })); // 横线
        }
        // canvas表格--逻辑 虚线
        let gridsize2 = 200; // 表格个数宽度
        let cellWidth2 = 200; // 表格大小
        for (var x = 1; x < canvas.width / gridsize2; x++) {
          canvas.add(new fabric.Line([cellWidth2 * x, 0, cellWidth2 * x, 800], { stroke: '#000000', strokeWidth: 1, strokeDashArray: [5, 5], selectable: false })); // 竖线
          canvas.add(new fabric.Line([0, cellWidth2 * x, 800, cellWidth2 * x], { stroke: '#000000', strokeWidth: 1, strokeDashArray: [5, 5], selectable: false })); // 横线
        }
        // ------------------------------------------------------------
        let LabeledRect = fabric.util.createClass(fabric.Rect, {
          type: 'labeledRect',

          initialize: function(options) {
            options || (options = {});

            this.callSuper('initialize', options);
            // give all labeled rectangles fixed width/heigh of 200/30
            // this.set({ width: 200, height: 20 });
            this.set('label', options.label || '');
          },

          toObject: function() {
            // 在实例中表示对象（和JSON）
            return fabric.util.object.extend(this.callSuper('toObject'), {
              label: this.get('label')
            });
          },

          _render: function(ctx) {
            // 绘制实例
            this.callSuper('_render', ctx);

            ctx.font = '18px Helvetica';
            ctx.fillStyle = '#333';
            ctx.fillText(this.label, -this.width / 2 + 5, -this.height / 2 + 17);
          }
        });

        var rect = new fabric.Rect({
          width: 200,
          height: 200,
          left: 0,
          top: 0,
          fill: '#ddd9ec' //紫    #f5c8e1+#c5afbb粉   #def4e1+#bac4bb绿  #d2e9fb+#b4bfc8蓝
        });

        let labeledRect = new LabeledRect({
          width: 200,
          height: 22,
          left: 0,
          top: 0,
          label: 'test',
          fill: '#6e6bf6'
        });

        var group = new fabric.Group([rect, labeledRect], {
          left: 200,
          top: 200
        });

        canvas.add(group);

        // todo: 添加事件   鼠标移入方框内 显示X  点击关闭方框
        // ------------------------------------------------------------
        // 添加事件
        canvas.on({
          'object:moving': onChange,
          'object:scaling': onChange,
          'object:rotating': onChange
        });

        function onChange(o) {
          o.target.setCoords();
          canvas.forEachObject(function(obj) {
            if (obj === o.target) return;
            // 重叠
            obj.set('opacity', o.target.intersectsWithObject(obj) ? 0.5 : 1);
          });
        }

        // ------------------------------------------------------------
        // 拖拽生成矩形
        var rect, isDown, origX, origY;

        canvas.on('mouse:down', o => {
          if (o.target !== null) {
            // console.log('not null');
          } else {
            // console.log('null');
            let pointer = canvas.getPointer(o.e);
            isDown = true;
            origX = pointer.x;
            origY = pointer.y;
            rect = new fabric.Rect({
              left: origX,
              top: origY,
              originX: 'left',
              originY: 'top',
              width: pointer.x - origX,
              height: pointer.y - origY,
              fill: 'rgba(255,0,0,0.5)'
            });

            canvas.add(rect);
          }
        });

        canvas.on('mouse:move', o => {
          if (!isDown) return;
          // bug：pointer在canvas外则生成canvas外部的对象，不能被边界限制住
          let pointer = canvas.getPointer(o.e);
          if (origX > pointer.x) {
            rect.set({ left: Math.abs(pointer.x) });
          }
          if (origY > pointer.y) {
            rect.set({ top: Math.abs(pointer.y) });
          }
          rect.set({ width: Math.abs(origX - pointer.x) });
          rect.set({ height: Math.abs(origY - pointer.y) });

          canvas.renderAll();
        });

        canvas.on('mouse:up', o => {
          isDown = false;
          //画图完成后可以选中和移动
          if (rect) {
            rect.setCoords();
          }
        });
        // ------------------------------------------------------------

        // ------------------------------------------------------------
        // 边界检测
        canvas.on('object:moving', o => {
          let pointer = canvas.getPointer(o.e);
          let pointer2 = o.target.getBoundingRect();
          // console.log(pointer, pointer2);

          var obj = o.target;
          // if object is too big ignore
          if (obj.currentHeight > obj.canvas.height || obj.currentWidth > obj.canvas.width) {
            return;
          }
          obj.setCoords();
          // top-left corner
          if (obj.getBoundingRect().top < 0 || obj.getBoundingRect().left < 0) {
            obj.top = Math.max(obj.top, obj.top - obj.getBoundingRect().top);
            obj.left = Math.max(obj.left, obj.left - obj.getBoundingRect().left);
          }
          // bot-right corner
          if (obj.getBoundingRect().top + obj.getBoundingRect().height > obj.canvas.height || obj.getBoundingRect().left + obj.getBoundingRect().width > obj.canvas.width) {
            obj.top = Math.min(obj.top, obj.canvas.height - obj.getBoundingRect().height + obj.top - obj.getBoundingRect().top);
            obj.left = Math.min(obj.left, obj.canvas.width - obj.getBoundingRect().width + obj.left - obj.getBoundingRect().left);
          }
        });

        $('#select-btn').on('click', function() {
          console.log(canvas.getActiveObject());
        });
        $('#inline-btn').on('click', function() {
          canvas.remove(canvas.getActiveObject());
          // // 该功能检查是否选择了组。如果选择了一个组，则该组的每个对象都将被删除。如果未选择任何组，则该函数会尝试删除所选对象。如果未选择任何内容，则不会更改画布。
          // if(canvas.getActiveGroup()) {
          //   canvas.getActiveGroup().forEachObject(function(o) { canvas.remove(o) });
          //   canvas.discardActiveGroup().renderAll();
          // } else {
          //   canvas.remove(canvas.getActiveObject());
          // }
        });
      });
    </script>
  </body>
</html>
